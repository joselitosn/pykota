#! /usr/bin/env python
# -*- coding: ISO-8859-15 -*-

# CUPSPyKota accounting backend
#
# PyKota - Print Quotas for CUPS and LPRng
#
# (c) 2003-2004 Jerome Alet <alet@librelogiciel.com>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
# $Id$
#
# $Log$
# Revision 1.37  2004/03/18 19:11:25  jalet
# Fix for raw jobs in cupspykota
#
# Revision 1.36  2004/03/18 14:03:18  jalet
# Added fsync() calls
#
# Revision 1.35  2004/03/16 12:05:01  jalet
# Small fix for new waitprinter.sh : when job was denied, would wait forever
# for printer being in printing mode.
#
# Revision 1.34  2004/03/15 10:47:56  jalet
# This time the traceback formatting should be correct !
#
# Revision 1.33  2004/03/05 12:46:07  jalet
# Improve tracebacks
#
# Revision 1.32  2004/03/05 12:31:35  jalet
# Now should output full traceback when crashing
#
# Revision 1.31  2004/03/01 14:35:56  jalet
# PYKOTAPHASE wasn't set soon enough at the start of the job
#
# Revision 1.30  2004/03/01 14:34:15  jalet
# PYKOTAPHASE wasn't set at the right time at the end of data transmission
# to underlying layer (real backend)
#
# Revision 1.29  2004/03/01 11:23:25  jalet
# Pre and Post hooks to external commands are available in the cupspykota
# backend. Forthe pykota filter they will be implemented real soon now.
#
# Revision 1.28  2004/02/26 14:18:07  jalet
# Should fix the remaining bugs wrt printers groups and users groups.
#
# Revision 1.27  2004/02/04 23:41:27  jalet
# Should fix the incorrect "backend died abnormally" problem.
#
# Revision 1.26  2004/01/30 16:35:03  jalet
# Fixes stupid software accounting bug in CUPS backend
#
# Revision 1.25  2004/01/16 17:51:46  jalet
# Fuck Fuck Fuck !!!
#
# Revision 1.24  2004/01/14 15:52:01  jalet
# Small fix for job cancelling code.
#
# Revision 1.23  2004/01/13 10:48:28  jalet
# Small streams polling loop modification.
#
# Revision 1.22  2004/01/12 22:43:40  jalet
# New formula to compute a job's price
#
# Revision 1.21  2004/01/12 18:17:36  jalet
# Denied jobs weren't stored into the history anymore, this is now fixed.
#
# Revision 1.20  2004/01/11 23:22:42  jalet
# Major code refactoring, it's way cleaner, and now allows automated addition
# of printers on first print.
#
# Revision 1.19  2004/01/08 14:10:32  jalet
# Copyright year changed.
#
# Revision 1.18  2004/01/07 16:16:32  jalet
# Better debugging information
#
# Revision 1.17  2003/12/27 16:49:25  uid67467
# Should be ok now.
#
# Revision 1.17  2003/12/06 08:54:29  jalet
# Code simplifications.
# Added many debugging messages.
#
# Revision 1.16  2003/11/26 20:43:29  jalet
# Inadvertantly introduced a bug, which is fixed.
#
# Revision 1.15  2003/11/26 19:17:35  jalet
# Printing on a printer not present in the Quota Storage now results
# in the job being stopped or cancelled depending on the system.
#
# Revision 1.14  2003/11/25 13:25:45  jalet
# Boolean problem with old Python, replaced with 0
#
# Revision 1.13  2003/11/23 19:01:35  jalet
# Job price added to history
#
# Revision 1.12  2003/11/21 14:28:43  jalet
# More complete job history.
#
# Revision 1.11  2003/11/19 23:19:35  jalet
# Code refactoring work.
# Explicit redirection to /dev/null has to be set in external policy now, just
# like in external mailto.
#
# Revision 1.10  2003/11/18 17:54:24  jalet
# SIGTERMs are now transmitted to original backends.
#
# Revision 1.9  2003/11/18 14:11:07  jalet
# Small fix for bizarre urls
#
# Revision 1.8  2003/11/15 14:26:44  jalet
# General improvements to the documentation.
# Email address changed in sample configuration file, because
# I receive low quota messages almost every day...
#
# Revision 1.7  2003/11/14 22:05:12  jalet
# New CUPS backend fully functionnal.
# Old CUPS configuration method is now officially deprecated.
#
# Revision 1.6  2003/11/14 20:13:11  jalet
# We exit the loop too soon.
#
# Revision 1.5  2003/11/14 18:31:27  jalet
# Not perfect, but seems to work with the poll() loop.
#
# Revision 1.4  2003/11/14 17:04:15  jalet
# More (untested) work on the CUPS backend.
#
# Revision 1.3  2003/11/12 23:27:44  jalet
# More work on new backend. This commit may be unstable.
#
# Revision 1.2  2003/11/12 09:33:34  jalet
# New CUPS backend supports device enumeration
#
# Revision 1.1  2003/11/08 16:05:31  jalet
# CUPS backend added for people to experiment.
#
#
#

import sys
import os
import popen2
import cStringIO
import shlex
import select
import signal
import time

from pykota.tool import PyKotaFilterOrBackend, PyKotaToolError
from pykota.config import PyKotaConfigError
from pykota.storage import PyKotaStorageError
from pykota.accounter import PyKotaAccounterError
from pykota.requester import PyKotaRequesterError
    
class PyKotaPopen3(popen2.Popen3) :
    """Our own class to execute real backends.
    
       Their first argument is different from their path so using
       native popen2.Popen3 would not be feasible.
    """
    def __init__(self, cmd, capturestderr=0, bufsize=-1, arg0=None) :
        self.arg0 = arg0
        popen2.Popen3.__init__(self, cmd, capturestderr, bufsize)
        
    def _run_child(self, cmd):
        for i in range(3, 256): # TODO : MAXFD in original popen2 module
            try:
                os.close(i)
            except OSError:
                pass
        try:
            os.execvpe(cmd[0], [self.arg0 or cmd[0]] + cmd[1:], os.environ)
        finally:
            os._exit(1)
    
class PyKotaBackend(PyKotaFilterOrBackend) :        
    """A class for the pykota backend."""
    def __init__(self) :
        """Does normal initialization then installs signal handler."""
        # Normal init
        PyKotaFilterOrBackend.__init__(self)
        
        # then deal with signals
        # CUPS backends ignore SIGPIPE and exit(1) on SIGTERM
        # Fortunately SIGPIPE is already ignored by Python
        # It's there just in case this changes in the future.
        # Here we have to handle SIGTERM correctly, and pass
        # it to the original backend if needed.
        self.gotSigTerm = 0
        signal.signal(signal.SIGPIPE, signal.SIG_IGN)
        signal.signal(signal.SIGTERM, self.sigterm_handler)
        
    def sigterm_handler(self, signum, frame) :
        """Sets a global variable whenever SIGTERM is received."""
        # SIGTERM will be ignore most of the time, but during
        # the call to the real backend, we have to pass it through.
        self.gotSigTerm = 1
        self.logger.log_message(_("SIGTERM received, job %s cancelled.") % self.jobid, "info")
        
    def acceptJob(self) :        
        """Returns the appropriate exit code to tell CUPS all is OK."""
        return 0
            
    def removeJob(self) :            
        """Returns the appropriate exit code to let CUPS think all is OK.
        
           Returning 0 (success) prevents CUPS from stopping the print queue.
        """   
        return 0
        
    def doWork(self, policy, printer, user, userpquota) :    
        """Most of the work is done here."""
        # Two different values possible for policy here :
        # ALLOW means : Either printer, user or user print quota doesn't exist,
        #               but the job should be allowed anyway.
        # OK means : Both printer, user and user print quota exist, job should
        #            be allowed if current user is allowed to print on this printer
        if policy == "OK" :
            # exports user information with initial values
            self.exportUserInfo(userpquota)
            
            # enters first phase
            os.putenv("PYKOTAPHASE", "BEFORE")
            
            # checks the user's quota
            action = self.warnUserPQuota(userpquota)
            
            # exports some new environment variables
            os.putenv("PYKOTAACTION", action)
            
            # launches the pre hook
            self.prehook(userpquota)
            
            self.logdebug("Job accounting begins.")
            self.accounter.beginJob(userpquota)
        else :    
            action = "ALLOW"
            os.putenv("PYKOTAACTION", action)
            
        # pass the job's data to the real backend    
        if action in ["ALLOW", "WARN"] :
            if self.gotSigTerm :
                retcode = self.removeJob()
            else :    
                retcode = self.handleData()        
        else :        
            retcode = self.removeJob()
        
        if policy == "OK" :        
            # indicate phase change
            os.putenv("PYKOTAPHASE", "AFTER")
            
            # stops accounting. 
            self.accounter.endJob(userpquota)
            self.logdebug("Job accounting ends.")
                
            # retrieve the job size    
            if action == "DENY" :
                jobsize = 0
                self.logdebug("Job size forced to 0 because printing is denied.")
            else :    
                jobsize = self.accounter.getJobSize()
            self.logdebug("Job size : %i" % jobsize)
            
            # update the quota for the current user on this printer 
            self.logdebug("Updating user %s's quota on printer %s" % (user.Name, printer.Name))
            jobprice = userpquota.increasePagesUsage(jobsize)
            
            # adds the current job to history    
            printer.addJobToHistory(self.jobid, user, self.accounter.getLastPageCounter(), action, jobsize, jobprice, self.preserveinputfile, self.title, self.copies, self.options)
            self.logdebug("Job added to history.")
            
            # exports some new environment variables
            os.putenv("PYKOTAJOBSIZE", str(jobsize))
            os.putenv("PYKOTAJOBPRICE", str(jobprice))
            
            # then re-export user information with new values
            self.exportUserInfo(userpquota)
            
            # Launches the post hook
            self.posthook(userpquota)
            
        return retcode    
                    
    def handleData(self) :                    
        """Pass the job's data to the real backend."""
        # Now it becomes tricky...
        # We must pass the unmodified job to the original backend
        # First ensure that we have a file object as input
        mustclose = 0    
        if self.inputfile is not None :    
            if hasattr(self.inputfile, "read") :
                infile = self.inputfile
            else :    
                infile = open(self.inputfile, "rb")
            mustclose = 1
        else :    
            infile = sys.stdin
            
        # Find the real backend pathname    
        realbackend = os.path.join(os.path.split(sys.argv[0])[0], self.originalbackend)
        
        # And launch it
        self.logdebug("Starting real backend %s with args %s" % (realbackend, " ".join(['"%s"' % a for a in ([os.environ["DEVICE_URI"]] + sys.argv[1:])])))
        subprocess = PyKotaPopen3([realbackend] + sys.argv[1:], capturestderr=1, bufsize=0, arg0=os.environ["DEVICE_URI"])
        
        # Save file descriptors, we will need them later.
        stdoutfno = sys.stdout.fileno()
        stderrfno = sys.stderr.fileno()
        fromcfno = subprocess.fromchild.fileno()
        tocfno = subprocess.tochild.fileno()
        cerrfno = subprocess.childerr.fileno()
        
        # We will have to be careful when dealing with I/O 
        # So we use a poll object to know when to read or write
        pollster = select.poll()
        pollster.register(fromcfno, select.POLLIN | select.POLLPRI)
        pollster.register(cerrfno, select.POLLIN | select.POLLPRI)
        pollster.register(stdoutfno, select.POLLOUT)
        pollster.register(stderrfno, select.POLLOUT)
        pollster.register(tocfno, select.POLLOUT)
        
        # Initialize our buffers
        indata = ""
        outdata = ""
        errdata = ""
        endinput = endoutput = enderr = 0
        inputclosed = outputclosed = errclosed = 0
        
        if self.preserveinputfile is None :
            # this is not a real file, we read the job's data
            # from stdin 
            infno = infile.fileno()
            pollster.register(infno, select.POLLIN | select.POLLPRI)
        else :    
            # job's data is in a file, no need to pass the data
            # to the real backend
            self.logdebug("Job's data is in %s" % self.preserveinputfile)
            infno = None
            endinput = 1
        
        killed = 0
        self.logdebug("Entering streams polling loop...")
        status = -1
        while status == -1 :
            # First check if original backend is still alive
            status = subprocess.poll()
            
            # Now if we got SIGTERM, we have 
            # to kill -TERM the original backend
            if self.gotSigTerm and not killed :
                try :
                    os.kill(subprocess.pid, signal.SIGTERM)
                    self.logger.log_message(_("SIGTERM was sent to real backend %s (pid: %s)") % (realbackend, subprocess.pid), "info")
                    killed = 1
                except : # ignore if process was already killed.
                    pass
            
            # In any case, deal with any remaining I/O
            availablefds = pollster.poll(5000)
            for (fd, mask) in availablefds :
                # self.logdebug("file: %i    mask: %04x" % (fd, mask))
                if mask & select.POLLOUT :
                    # We can write
                    if fd == tocfno :
                        if indata :
                            os.write(fd, indata)    
                            try :
                                os.fsync(fd)
                            except OSError :
                                pass
                            indata = ""
                        if endinput :    
                            pollster.unregister(tocfno)        
                            self.logdebug("Closing real backend's stdin.")
                            os.close(tocfno)
                            inputclosed = 1
                    elif fd == stdoutfno :
                        if outdata :
                            os.write(fd, outdata)
                            try :
                                os.fsync(fd)
                            except OSError :    
                                pass
                            outdata = ""
                        if endoutput :    
                            pollster.unregister(stdoutfno)        
                            outputclosed = 1
                    elif fd == stderrfno :
                        if errdata :
                            os.write(fd, errdata)
                            try :
                                os.fsync(fd)
                            except OSError :    
                                pass
                            errdata = ""
                        if enderr :    
                            pollster.unregister(stderrfno)        
                            errclosed = 1
                if (mask & select.POLLIN) or (mask & select.POLLPRI) :     
                    # We have something to read
                    data = os.read(fd, 256 * 1024)
                    if fd == infno :
                        indata += data
                        if not data :    # If yes, then no more input data
                            pollster.unregister(infno)
                            self.logdebug("Input data ends.")
                            endinput = 1 # this happens with real files.
                    elif fd == fromcfno :
                        outdata += data
                    elif fd == cerrfno :    
                        errdata += data
                if (mask & select.POLLHUP) or (mask & select.POLLERR) :
                    # I've never seen POLLERR myself, but this probably
                    # can't hurt to treat an error condition just like 
                    # an EOF.
                    # 
                    # Some standard I/O stream has no more datas
                    pollster.unregister(fd)
                    if fd == infno :
                        # Here we are in the case where the input file is stdin.
                        # which has no more data to be read.
                        self.logdebug("Input data ends.")
                        endinput = 1
                    elif fd == fromcfno :    
                        # This should never happen, since
                        # CUPS backends don't send anything on their
                        # standard output.
                        # We are no more interested in this file descriptor        
                        self.logdebug("Closing real backend's stdout.")
                        os.close(fromcfno)
                        endoutput = 1
                    elif fd == cerrfno :    
                        # Original CUPS backend has finished 
                        # to write informations on its standard error.
                        # We are no more interested in this file descriptor        .
                        self.logdebug("Closing real backend's stderr.")
                        os.close(cerrfno)
                        enderr = 1
            if killed or (inputclosed and outputclosed and errclosed) :
                break
                
        # We must close the real backend's input stream
        if killed and not inputclosed :
            self.logdebug("Forcing close of real backend's stdin.")
            os.close(tocfno)
        
        # Input file was a real file, we have to close it.    
        if mustclose :
            infile.close()
            
        self.logdebug("Exiting streams polling loop...")
            
        # Check exit code of original CUPS backend.    
        if status == -1 :
            # we exited the loop before the real backend exited
            # now we have to wait for it to finish and get its status
            status = subprocess.wait()
        if os.WIFEXITED(status) :
            retcode = os.WEXITSTATUS(status)
        elif not killed :    
            self.logger.log_message(_("CUPS backend %s died abnormally.") % realbackend, "error")
            retcode = -1
        else :    
            retcode = self.removeJob()
        return retcode    
    
if __name__ == "__main__" :    
    # This is a CUPS backend, we should act and die like a CUPS backend
    if len(sys.argv) == 1 :
        # we will execute each existing backend in device enumeration mode
        # and generate their PyKota accounting counterpart
        (directory, myname) = os.path.split(sys.argv[0])
        for backend in [os.path.join(directory, b) for b in os.listdir(directory) if os.path.isfile(os.path.join(directory, b)) and (b != myname)] :
            answer = os.popen(backend, "r")
            try :
                devices = [line.strip() for line in answer.readlines()]
            except :    
                devices = []
            status = answer.close()
            if status is None :
                for d in devices :
                    # each line is of the form : 'xxxx xxxx "xxxx xxx" "xxxx xxx"'
                    # so we have to decompose it carefully
                    fdevice = cStringIO.StringIO("%s" % d)
                    tokenizer = shlex.shlex(fdevice)
                    tokenizer.wordchars = tokenizer.wordchars + r".:,?!~/\_$*-+={}[]()#"
                    arguments = []
                    while 1 :
                        token = tokenizer.get_token()
                        if token :
                            arguments.append(token)
                        else :
                            break
                    fdevice.close()
                    try :
                        (devicetype, device, name, fullname) = arguments
                    except ValueError :    
                        pass    # ignore this 'bizarre' device
                    else :    
                        if name.startswith('"') and name.endswith('"') :
                            name = name[1:-1]
                        if fullname.startswith('"') and fullname.endswith('"') :
                            fullname = fullname[1:-1]
                        print '%s cupspykota:%s "PyKota+%s" "PyKota managed %s"' % (devicetype, device, name, fullname)
        retcode = 0
    elif len(sys.argv) not in (6, 7) :    
        sys.stderr.write("ERROR: %s job-id user title copies options [file]\n" % sys.argv[0])
        retcode = 1
    else :    
        try :
            # Initializes the backend
            kotabackend = PyKotaBackend()    
            retcode = kotabackend.mainWork()
        except (PyKotaToolError, PyKotaConfigError, PyKotaStorageError, PyKotaAccounterError, PyKotaRequesterError, AttributeError, KeyError, IndexError, ValueError, TypeError, IOError), msg :
            import traceback
            mm = [((f.endswith('\n') and f) or (f + '\n')) for f in traceback.format_exception(*sys.exc_info())]
            sys.stderr.write("ERROR : cupspykota backend failed (%s)\n%s" % (msg, "ERROR : ".join(mm)))
            sys.stderr.flush()
            retcode = 1
        
        try :
            kotabackend.storage.close()
        except (TypeError, NameError, AttributeError) :    
            pass
        
    sys.exit(retcode)    
