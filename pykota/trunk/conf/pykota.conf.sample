# PyKota sample configuration file
#
# Copy this file into the /etc/pykota/ directory
# under the name /etc/pykota/pykota.conf
#
# PyKota - Print Quotas for CUPS and LPRng
#
# (c) 2003 Jerome Alet <alet@librelogiciel.com>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
# $Id$
#

[global]
# Storage backend for quotas
# only PGStorage (PostgreSQL) and LDAPStorage (OpenLDAP) are supported.
# MySQL and BerkeleyDB are planned.

# the 'postgresql' value is deprecated, use 'pgstorage' instead.
storagebackend: pgstorage

# Quota Storage Server hostname (and optional port)
# e.g. db.mydomain.com:5432
storageserver: localhost

#
# name of the Quota Storage Database
storagename: pykota

# 
# Quota Storage normal user's name and password
# These two fields contain a username and optional password 
# which may give readonly access to your print quota database.
# 
# PLEASE ENSURE THAT THIS USER CAN'T WRITE TO YOUR PRINT QUOTA
# DATABASE, OTHERWISE ANY USER WHO COULD READ THIS CONFIGURATION
# FILE COULD CHANGE HIS PRINT QUOTA.
#
storageuser: pykotauser
# storageuserpw: Comment out if unused, or set to Quota Storage user password

# Should the database caching mechanism be enabled or not ?
# If unset, caching is disabled. Possible values Y/N/YES/NO
# caching mechanism works with both PostgreSQL and OpenLDAP backends
# but may be interesting only with OpenLDAP.
storagecaching: No

# LDAP example, uncomment and adapt it to your own configuration :
#storagebackend: ldapstorage
#storageserver: ldap://ldap.librelogiciel.com:389
#storagename: dc=librelogiciel,dc=com
#storageuser: cn=notadmin,dc=librelogiciel,dc=com
#storageuserpw: abc.123
#
# Here we define some helpers to know where 
# to plug into an existing LDAP directory
#userbase: ou=People,dc=librelogiciel,dc=com
#userrdn: uid
#balancebase: ou=People,dc=librelogiciel,dc=com
#balancerdn: uid
#groupbase: ou=Groups,dc=librelogiciel,dc=com
#grouprdn: cn
#printerbase: ou=Printers,ou=PyKota,dc=librelogiciel,dc=com
#printerrdn: cn
#jobbase: ou=Jobs,ou=PyKota,dc=librelogiciel,dc=com
#userquotabase: ou=UQuotas,ou=PyKota,dc=librelogiciel,dc=com
#groupquotabase: ou=GQuotas,ou=PyKota,dc=librelogiciel,dc=com
#lastjobbase: ou=LastJobs,ou=PyKota,dc=librelogiciel,dc=com
#
# How to create new accounts and groups
# authorized values are "below" and "attach(objectclass name)"
#
# "below" creates the new accounts/groups as standalone entries
# below the above defined 'userbase' ou
# 
# attach(objectclass name) tries to find some existing user/group
# using the above defined 'userrdn' or 'grouprdn' and 'userbase'
# 'groupbase', and attach the PyKota specific entries to it.
#
# a possible value:  newuser: attach(posixAccount)
#newuser : below
#newgroup : below
#
# LDAP attribute which stores the user's email address
#usermail : mail

# 
# Choose what attribute contains the list of group members
# common values are : memberUid, uniqueMember, member
#groupmembers: memberUid

# Where to log ?
# supported values : stderr, system (system means syslog, but don't use 'syslog' here)
# if the value is not set then the default SYSTEM applies.
logger: system

# Enable debugging ? Put YES instead here,
# but only if something went wrong and you want
# to learn from where the problem comes from.
# Actually only database queries are logged.
debug : No

# Mail server to use to warn users
# If the value is not set then localhost is used.
smtpserver: localhost

# What is the accounting backend to use
# 
# supported values :
#
#    - querying : asks the printer for its lifetime page counter
#                 via either SNMP, AppleTalk, or any external
#                 command. This method is the method used by
#                 default in PyKota since its beginning.
#
#    - external : delegates the job's size computation to any 
#                 external command of your choice. A stupid and 
#                 completely unreliable example, but which
#                 shows what this command may be is :
#
#                   accounter: external(/bin/grep -c showpage)
#
#                 Another one, which should work with all DSC
#                 compliant Postscript files :
#
#                   accounter: external(/bin/grep -c "%%Page:")
# 
#    - stupid : counts the occurences of the 'showpage' postscript
#               statement in the document to be printed.
#               THIS IS NOT RELIABLE. This is just to serve as
#               an example on how to implement your own accounting
#               method.
#
# This value can be set either globally or on a per printer basis
# If both are defined, the printer option has priority.
# if not set it defaults to 'querying'.
#
# A script which seems to be accurate, copy it from the
# untested/postscript directory to another place.
# accounter: external(/usr/local/bin/pagecount.sh)
# WARNING : it may not work when multiple copies are asked.
#           this breaks ghostscript, I don't know why yet.
#
# default value 
accounter: querying

# Print Quota administrator
# These values can be set either globally or per printer or both.
# If both are defined, the printer option has priority.
# If these values are not set, the default admin root 
# and the default adminmail root@localhost are used.
admin: Jerome Alet
adminmail: alet@librelogiciel.com

#
# Who should we send an email to in case a quota is reached ?
# possible values are : DevNull, User, Admin, Both
# The Both value means that the User and the Admin will receive 
# an email message.
# The DevNull value means no email message will be sent.
# This value can be set either globally or per printer or both.
# If both are defined, the printer option has priority.
# If the value is not set, then the default BOTH applies.
mailto: both

#
# Grace delay in days
# This value can be set either globally or per printer or both.
# If both are defined, the printer option has priority.
# If the value is not set then the default seven (7) days applies.
gracedelay: 7

#
# Poor man's threshold
# If account balance reaches below this amount,
# a warning message is sent by email
#
# If unset, default poor man's threshold is 1.0.
# This option can only appear in the global section
poorman: 2.0

# Poor man's warning message
# The warning message that is sent if the "poorman" value is reached
# Again this must appear in the global section
poorwarn: Your Print Quota account balance is low. 
 Soon you'll not be allowed to print anymore.

# Soft limit reached warning message
# The warning message that is sent if the soft quota limit is reached
# May appear either globally or on a per-printer basis
softwarn: Your Print Quota Soft Limit is reached.
 This means that you may still be allowed to print for some
 time, but you must contact your administrator to purchase 
 more print quota.
 
# Hard limit reached error message
# The error message that is sent if the hard quota limit is reached
# May appear either globally or on a per-printer basis
hardwarn: Your Print Quota Hard Limit is reached.
 This means that you are not allowed to print anymore.
 Please contact your administrator at root@localhost
 as soon as possible to solve the problem.

# one section per printer, or no other section at all if all options 
# are defined globally.
# Each section's name must be the same as the printer's queue name as defined
# in your printing system, be it CUPS or LPRng.
# If you don't want any special printer section, just comment out
# the line below so that following options are global.
[hpmarketing]

# How to query the hpmarketing printer for its page counter.
# THIS IS ONLY USED IF YOU HAVE SET 'accounter' TO 'querying'
# JUST COMMENT IT OUT IF YOU USE ANY OTHER ACCOUNTING METHOD.
# (it would be ignored anyway)
#
# In the lines below "%(printer)s" is automatically replaced
# at run time with your printer's Fully Qualified Domain Name
# e.g. myprinter.domain.com
#
# Only snmp(community, oid) and external(command) are supported
#
# Example : 
#     requester: external(/usr/bin/snmpget -v1 -c public -Ov %(printer)s mib-2.43.10.2.1.4.1.1 | cut -f 2,2 -d " ")
# and :
#     requester: snmp(public, mib-2.43.10.2.1.4.1.1)
# are equivalent
#
# Another untested example, using npadmin :
#     requester: external(/usr/bin/npadmin --pagecount %(printer)s)
#
# Another example, for AppleTalk printers which works fine :
# (You may need the pap CUPS backend installed, and copy the 
# pagecount.ps file from untested/netatalk into /etc or any 
# appropriate location)
#     requester: external(/usr/bin/pap -p "%(printer)s:LaserWriter" /etc/pagecount.ps  2>/dev/null | grep -v status | grep -v Connect | tail -1)
#
# This value can be set either globally or per printer or both.
# If both are defined, the printer option has priority.
#
# NB : The SNMP oid mib-2.43.10.2.1.4.1.1 works on HP Laserjet Printers, but it may
#      be different with other brands, refer to your printer's documentation 
#      for details. Also you may have to specify -v2c or -v3 depending on your 
#      printer's support for different versions of the SNMP specification.
#
#
# Some examples and comments provided by Bob Martel from csuohio.edu
#
# For several printers I could not get the page count using snmpget.  I
# resorted to snmpwalk:
# 
# requester: external(/opt/local/net-snmp/bin/snmpwalk -v 1 -Cc -c public %(printer)s | grep mib-2.43.10.2.1.4.1.1 | cut -d " " -f4)
#
# The last example is still more ugly, some of the printers only provided
# their counters without names, but at least always on the same line:
#
# requester: external(/opt/local/net-snmp/bin/snmpwalk -v 1 -Cc -c public -Ov %(printer)s | grep Counter32 | tail -2 | head -1 | cut -d " " -f2)
#
#
# An example using netcat and a preformatted PJL job which you can find
# in the untested/pjl directory, which is sent to a JetDirect print
# server on port 9100 :
#
# requester: external(/bin/nc -w 2 %(printer)s 9100 <pagecount.pjl | /usr/bin/tail -2)
#
#
# WARNING : In any case, when using an external requester, please test the command line outside
#           of PyKota before. This will save you some headaches in case it doesn't work as expected.
#
# The waitprinter.sh is there to wait until the printer is idle again.
# This should prevent a job to be sent to the printer while another one is 
# not yet finished (not all pages are printed, but the complete job is in 
# the printer)
requester: external(/usr/bin/waitprinter.sh %(printer)s && /usr/bin/snmpget -v1 -c public -Ov %(printer)s mib-2.43.10.2.1.4.1.1 | cut -f 2,2 -d " ")

# Default policy for inexistant users (e.g. root)
# either allow or deny
# This value can be set either globally or per printer or both.
# If both are defined, the printer option has priority.
# If the value is not set then the default policy DENY applies.
# ATTENTION :
#     Before 1.04 the default value was ALLOW, but unknown users
#     allowed to print causes accuracy problems : their jobs are
#     charged to the next person who prints on the same printer.
# There's no policy wrt inexistant groups, they are ignored.
policy: deny

